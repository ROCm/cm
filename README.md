# cm

Note: This README is generated by [build.rs](build.rs)

## Contributing

If you would like to contribute, please read [CONTRIBUTING.md](CONTRIBUTING.md)

## Purpose

Frontend for configuring/building/testing CMake projects (see --help for more details)

Provides a subcommand-based interface with saner defaults for working with CMake projects,
with special support for LLVM.

All subcommands share a common interface for specifying the source (-s/--source) and binary
(-b/--binary) paths, as well as the config (-c/--config).

Typical usage of the tool involves leaving a shell parked at the top-level of the CMake project
and running subcommands (note that the subcommand can be abbreviated):

    $ cm configure      # default values for --source, --binary, and --config are used
    $ cm build          # ditto
    $ # assuming the project is LLVM...
    $ cm l -g llvm      # Run a test group
    $ cm l -v
    $ ...               # Resolve tests failures, referencing full verbose test output
    $ cm l
    $ ...
    $ cm l -1v          # Focus on only one test, implicitly not touching the ResultDB
    $ ...               # Fix the test
    $ cm l              # Record the fix into the ResultDB

With non-default values for --source/--binary/--config you can leave these options alone across
subcommands:

    $ cm -s src -b bin -c debug c
    $ cm -s src -b bin -c debug b
    $ cm -s src -b bin -c debug b check-llvm
    $ cm -s src -b bin -c debug l
    $ cm -s src -b bin -c debug l -v
    $ # ...
    $ cm -s src -b bin -c debug l

For the bash and zsh shells the "activate" subcommand automates pinning these values via
environment variables and updates "PATH" to search the bin subdirectory in the binary path:

    $ eval $(cm -s src -b bin -c debug activate)
    $ echo "$CM_SRC"
    $PWD/src
    $ echo "$CM_BIN"
    $PWD/bin
    $ echo "$CM_CFG"
    Debug
    $ echo "$PATH"
    $PWD/bin/bin:$ORIG_PATH

Tip: Including these variable in your shell's prompt can make it easier to track when you have
activated/deactivated for different projects.

Tip: The source and binary paths are converted to absolute paths, so once activated you can
also change directories and continue to run cm commands and binaries from your build without
having to locate the project root.

The "deactivate" subcommand automates reversing an "activate":

    $ # beginning with the environment from above...
    $ eval $(cm deactivate)
    $ echo "$CM_SRC"
    $ echo "$CM_BIN"
    $ echo "$CM_CFG"
    $ echo "$PATH"
    $ORIG_PATH

Global configuration is read from a file named "cm.rc" in the platform-specific user config
directory (e.g. on Linux this is probably $XDG_CONFIG_HOME/cm.rc or ~/.config/cm.rc). This can
be controlled by setting the environment variable CM_CONFIG_PATH: if set to the empty string
then no configuration file is used, and otherwise the value is interpreted as an alternative
path to a config file to read.

The config file format is line-based, where each line is either:

* A comment, starting with '#'
* An argument, starting with '-' and being interpreted verbatim (i.e. no quoting)
* A subcommand identifier, otherwise

Arguments before any subcommand identifier are global, and apply to all "cm" invocations.
Arguments under a specific subcommand identifier only apply for cm invocations with the
appropriate subcommand specified.

An example config:

    # make the default source dir path be src
    --source=src
    # disable quirks-mode detection
    --quirks=none

    # switch "sections"
    configure
    # (the following args will only apply to the configure subcommand)
    # set a global prefix path dir
    --prefix-path=/some/absolute/dir
    # default to make rather than Ninja
    --generator=Unix Makefiles

    # switch "section" again
    lit
    # do not generate a resultdb by default
    --update-resultdb=false

Overall, the order in which arguments are evaluated is (later wins):

* Config file (e.g. ~/.config/cm.rc)
* Environment variables (e.g. CM_SRC, CM_BIN, ...)
* Command-line options

Flags are idempotent, and have forms to explicitly specify their defaults (e.g. boolean options
generally have an --option=false form), so that setting them in the config file does not limit
the user on the command-line (i.e. you can always override your own configured defaults).

## Usage

```text
cm [OPTIONS] <COMMAND>

Commands:
  configure   CMake Configure [aliases: c]
  build       CMake Build [aliases: b]
  lit         llvm-lit [aliases: l]
  activate    Print shell commands to activate a set of global options [aliases: a]
  deactivate  Print shell commands to deactivate global options set via activate [aliases: d]
  help        Print this message or the help of the given subcommand(s)

Options:
  -h, --help
          Print help (see a summary with '-h')

  -V, --version
          Print version

Global Options:
  -s, --source <SOURCE>
          CMake Source Directory
          
          [default: .]
          
          [env: CM_SRC=]

  -b, --binary <BINARY>
          CMake Binary Directory
          
          [default: ./build]
          
          [env: CM_BIN=]

  -c, --config <CONFIG>
          CMake Build Config
          
          [default: RelWithDebInfo]
          
          [env: CM_CFG=]
          [possible values: Release, Debug, RelWithDebInfo, MinSizeRel]

  -q, --quirks <QUIRKS>
          Disable quirk mode detection and specify one explicitly
          
          [default: none]
          
          [env: CM_QUIRKS=]
          [possible values: none, llvm]

  -#, --dry-run[=<BOOL>]
          Perform a dry run, only printing the generated command line
```